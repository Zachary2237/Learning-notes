# 面向对象

## 5.1 多态性

多态:一个事物的多种形态

对象的多态性:父类的引用指向子类的对象(子类的对象赋给父类的引用)

```
Person p1 = new Person();
Person p2 = new Man();
Person p3 = new Woman();
```

## 5.2 多态的使用

当调用子父类同名同参数的方法时,实际执行的时子类重写的方法. --虚拟方法调用

有了对象的多态性以后,我们在编译期只能调用父类中声明的方法,但在执行期,实际执行的是子类重写的父类的方法

总结:编译看左边,运行看右边

## 5.3 多态性的使用前提

1. 要有类的继承关系
2. 要有方法的重写

对象的多态性,只适用于方法,不适用于属性.(编译和运行都看左边)

## 5.4 多态性的补充内容

1. 
```
Person p1 = new Man()
p1.earnMoney()
```
earnMoney是子类中特有的方法\属性,这样是非法的,在编译时,p1是Person类型,不能调用子类特有的方法.

有了对象的多态性以后,内存中实际上是加载了子类特有的属性和方法,但是由于变量声明为父类类型,导致编译时只能调用父类中所声明的属性和方法.子类特有的属性和方法不能调用.

2. 如何才能调用子类特有的属性和方法

向下转型:使用强制类型转换符

```
Man m1 = (Man)p1
m1.earnMoney()
```

![9](https://user-images.githubusercontent.com/91724689/193399512-21bb1ce1-0529-4064-9e97-ae8e9a2dd599.JPG)

3. 使用强转时,可能会出现ClassCastException的异常

instanceof关键字的使用:

- a instanceof A ：判断对象ａ是否是类Ａ的实例，如果是，返回true，否则返回false．

- 为了避免在向下转型时出现ClassCastException的异常，在向下转型之前通常先进行instanceof的判断，如果返回true，就进行向下转型，否则不进行向下转型

- 如果a instanceof A 返回true，则 a instanceof B 也返回true，其中类B是类A的父类

4. 强转的总结：

对Java对象的强制类型转换称为造型
- 从子类到父类的类型转换可以自动进行
- 从父类到子类的类型转换必须通过造型(强制类型转换)实现
- 无继承关系的引用类型间的转换是非法的
- 在造型前可以使用instanceof操作符测试一个对象的类型

5. 小练习与总结

![10](https://user-images.githubusercontent.com/91724689/193400691-4792dbec-d607-4944-b147-8ade0288df27.JPG)

总结，子类继承父类：

- 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，系统将不可能把父类里的方法转移到子类中。（编译看左边，运行看右边）
- 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量

6. 一道多态性的笔试题

![11](https://user-images.githubusercontent.com/91724689/193405806-38919993-a272-4eb7-9d1b-462608eca17b.JPG)

- int... arr 代表可变形参
- 问题纠结的地方在于，如果认为是方法重写，则为sub_1，如果不是重写，则为base1
- 在注释情况下，答案是sub_1,也就是说这是方法的重写
- 打开sub_2的注释，运行结果仍为sub_1
- 打开所有注释，结果为sub_2，因为父类中的构造器中形参列表int... arr不确定多个，子类中a，b，c确定多个，优先调用确定多的

## 6.1 Object类的使用

1. Object类是所有Java类的根父类
2. 如果在类的声明中没有使用extends关键字指定其父类，则默认父类为java.lang.Object类
3. Object类中的功能（属性、方法）具有通用性
  - 属性：无
  - 方法：equals() / toString() / getclass() / hashCode() / clone() / finalize() / wait() , notify() , notifyAll()  
4. Object类只声明了一个空参构造器
